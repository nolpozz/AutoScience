"""
Build a Jupyter notebook (.ipynb) from successful script contents for reproducibility.

The generated notebook interleaves Codex-generated markdown cells with code cells so
that each section of code is preceded by an explanation of:
- what the code is doing,
- why this approach was chosen,
- and alternative choices that could have been made.
"""

from pathlib import Path
from typing import Sequence

from core.codex_runner import run_codex

try:
    import nbformat
    from nbformat.v4 import new_notebook, new_code_cell, new_markdown_cell
except ImportError:
    nbformat = None  # type: ignore
    new_notebook = new_code_cell = new_markdown_cell = None  # type: ignore


def _split_script_into_chunks(code: str) -> list[str]:
    """
    Split a script into smaller, top-level chunks so that large files do not appear
    as a single monolithic code cell in the notebook.

    Heuristics:
    - Keep the initial preamble (shebang, docstring, imports, constants) together.
    - Start a new chunk at each top-level `def`, `class`, or `if __name__ == "__main__":`
      guard.

    This preserves Python semantics (we never split inside a function body) while
    creating smaller, easier-to-explain units for Codex.
    """
    lines = code.splitlines()
    chunks: list[list[str]] = []
    current: list[str] = []

    def flush_current() -> None:
        if current and any(line.strip() for line in current):
            chunks.append(current.copy())
        current.clear()

    for line in lines:
        stripped = line.lstrip()
        is_boundary = (
            line.startswith("def ")
            or line.startswith("class ")
            or line.startswith('if __name__ == "__main__":')
            or line.startswith("if __name__ == '__main__':")
        )
        if is_boundary and current:
            flush_current()
        current.append(line)
    flush_current()

    return ["\n".join(block).rstrip() + "\n" for block in chunks if any(l.strip() for l in block)]


def _generate_markdown_for_chunk(code: str, script_path: Path, index: int, total: int) -> str:
    """
    Ask Codex to produce an explanatory markdown cell for a single top-level chunk
    of a script.

    The prompt is phrased so that Codex returns plain markdown text that can be used
    directly as a notebook markdown cell sitting immediately above this chunk's code.
    """
    # Lightweight guard: if there is no code, do not bother Codex.
    if not code.strip():
        return ""

    prompt = f"""
You are helping to build a reproducible Jupyter notebook for a data analysis project.

Below is a single top-level section from a Python analysis or visualization script
that has already been verified to run successfully. The full script is being
converted into multiple notebook cells; this is section {index} of {total}.

Script path: {script_path}

```python
{code}
```

Write a single markdown cell that will appear directly above this code cell in the
notebook. The markdown must:

- Explain in plain language what this section of the script does.
- Summarize why this general approach was chosen for this part of the workflow.
- Briefly mention one or two alternative approaches or models that could be used
  instead, and when they might be preferable.

Requirements:
- Do NOT include any code blocks or backticks in your answer.
- Do NOT restate the entire code; focus on the ideas and reasoning.
- Use short headings and/or bullet points where helpful.
""".strip()

    try:
        # Run Codex in the script's directory so relative paths (if any) make sense.
        stdout, _ = run_codex(prompt, cwd=script_path.parent, timeout_seconds=600, stream=False)
    except FileNotFoundError:
        # Codex CLI not available; fall back to a generic placeholder.
        return (
            "This cell runs a section of an analysis or visualization script that was "
            "part of the AutoScience pipeline. Codex was unavailable, so a detailed "
            "natural-language explanation could not be generated automatically."
        )

    markdown = stdout.strip()
    # If Codex produced nothing useful, fall back to a basic description.
    if not markdown:
        markdown = (
            "This cell executes one part of an analysis or visualization script "
            "generated by the AutoScience pipeline. It contributes to data preparation, "
            "modeling, or figure creation in support of the research question."
        )
    return markdown


def build_notebook_from_scripts(
    script_paths: Sequence[Path],
    output_path: Path,
    title: str = "Reproducible Analysis",
    markdown_intro: str = "",
) -> Path:
    """
    Create a single .ipynb that runs the given scripts in order.

    For each script, this function:
    - calls Codex to generate an explanatory markdown cell,
    - then adds the script itself as a code cell,
    so the notebook interleaves narrative and code throughout.

    :param script_paths: Ordered list of paths to .py files (successful analysis/viz scripts).
    :param output_path: Where to write the .ipynb.
    :param title: Notebook title (first markdown cell).
    :param markdown_intro: Optional intro markdown after the title.
    :return: output_path.
    """
    if nbformat is None:
        raise ImportError("nbformat is required. Install with: pip install nbformat")

    nb = new_notebook()
    header_text = f"# {title}".strip()
    if markdown_intro.strip():
        header_text = f"{header_text}\n\n{markdown_intro.strip()}"
    cells = [new_markdown_cell(header_text)]

    for path in script_paths:
        p = Path(path)
        if not p.exists():
            continue
        full_code = p.read_text(encoding="utf-8")
        chunks = _split_script_into_chunks(full_code)
        if not chunks:
            continue

        total_chunks = len(chunks)
        for idx, chunk in enumerate(chunks, start=1):
            explanation_md = _generate_markdown_for_chunk(chunk, p, idx, total_chunks)
            if explanation_md:
                cells.append(new_markdown_cell(explanation_md))
            cells.append(new_code_cell(chunk))

    nb["cells"] = cells
    out = Path(output_path)
    out.parent.mkdir(parents=True, exist_ok=True)
    with open(out, "w", encoding="utf-8") as f:
        nbformat.write(nb, f)
    return out
